<!DOCTYPE html><html lang=en><head><meta charset=UTF-8><meta name=description content="MIPSym is an academic tool used to teach assembly language programming."><meta name=keywords content="MIPS MIPSym simulation assembler R2000 R3000"><title>MIPSym Cross Compile</title><link rel=icon href=resources/img/favicon.ico><meta name=viewport content="width=device-width, initial-scale=1"><script>(function(i,s,o,g,r,a,m){{i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){{(i[r].q=i[r].q||[]).push(arguments)}},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)}})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-84648174-1', 'auto');ga('send', 'pageview');</script><link rel=stylesheet href=resources/include/styles/mipsym-bootstrap.css type=text/css><script src=https://code.jquery.com/jquery-3.4.1.slim.min.js integrity=sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js integrity=sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6 crossorigin=anonymous></script></head><body><nav class="navbar navbar-expand-md navbar-dark bg-dark"><a class=navbar-brand href=#>MIPSym.com</a><button class=navbar-toggler type=button data-toggle=collapse data-target=#pageNavbar aria-controls=pageNavbar aria-expanded=false aria-label="Toggle page navigation"><span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=pageNavbar><ul class="nav navbar-nav mr-auto"><li id=DownloadsNavBar class=nav-item><a class=nav-link href=index.html>Downloads</a></li><li id=DocumentationNavBar class=nav-item><a class=nav-link href=Documentation.html>Documentation</a></li><li id=ChangeLogNavBar class=nav-item><a class=nav-link href=ChangeLog.html>Change Log</a></li><li id=CrossCompileNavBar class="nav-item active"><a class=nav-link href=#>Cross Compile</a></li><li id=AboutNavBar class=nav-item><a class=nav-link href=About.html>About</a></li></ul></div></nav><div class=container><h1>How to cross-compile C/C++ code to MIPS assembly</h1><hr><h2>Cross Compile With Clang</h2><h3>Install <a href=https://clang.llvm.org/ >clang/llvm</a>:</h3><ul><li>Windows: Download a binary from <a href=https://releases.llvm.org/download.html>llvm.org</a>, or use MSys2 and <code>pacman -S mingw64/mingw-w64-x86_64-clang</code>.</li><li>Mac: Use the XCode version, or install via brew: <code>brew install llvm</code></li><li>Linux: <code>sudo apt install clang</code></li></ul><h3>Cross-compile some code</h3><p>Run this:</p><div class=codehilite><pre><span></span><code>$ clang -O3 -S -target mips -mcpu<span class=o>=</span>mips32 some_program_file.c
</code></pre></div><p>Note the following command line options:</p><ol><li><strong>-O3</strong> This flag indicates the highest level of optimization. You can also try using -Os, which optimizes for size instead of speed.</li><li><strong>-S</strong> This flag tells the compiler to generate an assembly file instead of machine code binary.</li><li><strong>-target mips</strong> This flag tells clang to cross-compile to the MIPS architecture instead of the architecture you're running the compiler on. The argument of <code>-target</code> should actually be a "target triple": see <a href=https://clang.llvm.org/docs/CrossCompilation.html#target-triple>Clang Cross Compilation docs</a> for more information. If you have <code>llvm</code> installed, you should be able to list all the parameters to this "target triple" using the CLI command <code>llc -march=mips -mattr=help</code>.</li><li><strong>-mcpu=mips32</strong> This flag indicates the specific CPU you are writing for. <code>mips32</code> gets us very close to the R2000 that MIPSym emulates.</li></ol><p>Note that clang does not come with a standard library for MIPS, so if you start <code>#include</code>ing your favorite library headers, you'll get compiler errors unless you install those headers yourself.</p><p>If you want to cross-compile code that uses standard libraries, see the following section.</p><hr><h2>Cross Compile With GCC</h2><p>The GCC MIPS cross-compilers are readily available in binary form on Linux. If you have loads of patience, you may be interested in compiling a GCC MIPS cross-compiler from source on some other OS; this is a non-trivial task that I cannot help you with.</p><p>On my installation of Ubuntu 18.04, binaries of gcc-mips are available in the standard built-in repositories. If you are not on Ubuntu 18.04, you may need to add some new repositories. Run a search for "gcc MIPS" and you should find what you need.</p><p>Windows: You can get this to work using <a href=https://docs.microsoft.com/en-us/windows/wsl/install-win10>Windows Subsystem Linux 2</a>. This will require you to install a Linux distribution (there are several options) on a virtual machine running on your Windows desktop. One of the choices is Ubuntu 18.04; I can confirm that these instructions will work on that distro, but I haven't tried the others.</p><h3>1.) Install the MIPS GCC cross compiler.</h3><h4>Find GCC cross compiler packages</h4><p>The gcc cross compiler is named something like <code>gcc-mips-linux-gnu</code> or <code>gcc-8-mips-linux-gnu</code>. You can see what's available in the <code>apt</code> package manager by running <code>apt search</code>:</p><div class=codehilite><pre><span></span><code>$ apt search --names-only <span class=s1>&#39;^gcc-.*mips-linux-gnu$&#39;</span>
</code></pre></div><p>This command uses a regular expression to cut down on the number of results. My machine lists over 500 packages related to gcc mips cross-compilation, and the regular expression cuts this down to the 10 most relevant. In this guide, I will install the default gcc/g++, which corresponds to GCC-7.5.0. </p><p>You should be able to use <code>apt search</code> to find MIPS cross compilers on any Linux distribution that uses the <code>apt</code> package manager. Before Ubuntu 18.04 was released, you had to use <code>apt-cache</code> instead of <code>apt</code> to run the search command; keep this in mind in case <code>apt search</code> doesn't work.</p><p>On Linux distros that do not use <code>apt</code>, you should be able to query your package manager for packages that include the terms <code>gcc</code> and <code>mips</code>; you will be able to find something useful on most distros.</p><h4>Install the GCC cross compiler</h4><p>You found the package you wanted, now install it:</p><div class=codehilite><pre><span></span><code>$ sudo apt install gcc-mips-linux-gnu g++-mips-linux-gnu
</code></pre></div><p>Please note that after you install the package <code>gcc-mips-linux-gnu</code>, you cannot simply run <code>gcc-mips-linux-gnu</code> from a terminal. This package actually installs a binary called <code>mips-linux-gnu-gcc</code> in your <code>/usr/bin</code> directory. Let's try to run it now, just to make sure it installed correctly:</p><div class=codehilite><pre><span></span><code>$ mips-linux-gnu-gcc --version
</code></pre></div><p>If this command fails to run, then either the cross-compiler was not installed, or you have the wrong program name.</p><p>For future reference, if you installed a package with <code>apt</code> and you can't figure out what you actually installed, you can use this command to find out:</p><div class=codehilite><pre><span></span><code>$ dpkg -L gcc-mips-linux-gnu
</code></pre></div><p><code>dpkg</code> is the Debian package manager. <code>apt</code> is a user-friendly front-end for <code>dpkg</code>, but occasionally there are some things that <code>apt</code> cannot do. The <code>dpkg -L</code> command lists everything that a particular package installed, and where it went. In this case, <code>gcc-mips-linux-gnu</code> installed several manuals, tools, and the <code>mips-linux-gnu-gcc</code> compiler.</p><h3>2.) Cross compile some code.</h3><p>I used a simple hello world program, provided below:</p><div class=codehilite><pre><span></span><code><span class=c1>// hello.c</span>
<span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp></span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>){</span>
    <span class=n>puts</span><span class=p>(</span><span class=s>&quot;Hello world</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>To compile this program, use this command:</p><div class=codehilite><pre><span></span><code>$ mips-linux-gnu-gcc -O3 -S -mfp32 -march<span class=o>=</span>R2000 hello.c
</code></pre></div><p>This command will result in an assembly file called 'hello.s'. If you want to compile c++ code, replace the 'gcc' part with 'g++', like this:</p><div class=codehilite><pre><span></span><code>$ mips-linux-gnu-g++ -O3 -S -mfp32 -march<span class=o>=</span>R2000 hello.cpp
</code></pre></div><p>Please note that the current MIPSym assembler cannot assemble this file directly; gcc outputs several assembler directives that the MIPSym assembler does not understand, and gcc writes all of the registers as numbers ($0-$31), while MIPSym only understands the registers by their descriptive names ($t0-$t9, $s0-$s7, etc). In addition, gcc links the output to gcc's version of stdio, which MIPSym cannot do.</p><p>When I ran gcc on the hello.c file, I wound up with a 46-line assembly program. Most of this program is assembler directives that MIPSym doesn't understand and code that sets up the linkage to stdio. Using g++ instead, I get 54 lines. Using iostream instead of stdio, I get 110 lines!</p><p>To check the length of your output, try word-count:</p><div class=codehilite><pre><span></span><code>$ wc -l hello.s
</code></pre></div><p>If you want the MIPSym assembler to compile code produced by gcc, take special care with the delay slots. I have found that some cross compilers don't use the delay slot properly: much of the code that gcc outputs is written with the delay slot in mind, but occasionally I can find a few instances where the delay slot should contain a nop, but instead it contains the instruction that should come after the nop.</p><h3>3.) Understand the compiler flags you just used.</h3><p>On linux, you shouldn't ever pass flags into a command-line program without taking some time to understand what they do. To do this, you can check the gcc manpage by typing:</p><div class=codehilite><pre><span></span><code>$ man mips-linux-gnu-gcc
</code></pre></div><p>You can also check their <a href=https://gcc.gnu.org/onlinedocs/gcc>online documentation</a>. You'll find the MIPS flags <a href=https://gcc.gnu.org/onlinedocs/gcc/MIPS-Options.html>here</a>.</p><p>For a brief rundown of all the command-line arguments, try the <code>--help</code> flag:</p><div class=codehilite><pre><span></span><code>$ mips-linux-gnu-gcc --help
</code></pre></div><p>Be aware that gcc has over 2000 flags, so don't try to learn them all. These are the ones that I used:</p><ol><li><strong>-O3</strong> This flag specifies the highest level of optimization. This flag is pretty important if you want to generate a readable quantity of assembly. My c++ version of 'hello world', using iostream, generates 110 lines of code with this flag, and 202 without it! You can also try using -Os, which optimizes for size instead of speed.</li><li><strong>-S</strong> This flag tells gcc to generate an assembly file instead of machine code binary.</li><li><strong>-mfp32</strong> The '-m' flags generally indicate a machine-specific directive. This flag tells gcc to use 32-bit floating point registers.</li><li><strong>-march=R2000</strong> This flag specifies the R2000 processor. Gcc supports quite a few processors; check the website listed above for more.</li></ol><h3>4.) Use gcc's assembler to assemble an object file.</h3><p>To assemble hello.s, use this command:</p><div class=codehilite><pre><span></span><code>$ mips-linux-gnu-gcc -c -EB hello.s
</code></pre></div><p>The <code>-c</code> flag compiles and assembles input files so that they will become object files, but does not link them into executable files. The <code>-EB</code> flag tells gcc to produce big-endian output.</p><p>This command will produce <code>hello.o</code>. You are encouraged to open this file in objdump, or a GUI hex editor like GHex, and see what you find. In the data section, you should be able to find the string <code>"Hello world\n"</code>. In the text section, you should be able to locate the machine code that corresponds to the assembly opcodes in <code>hello.s</code>.</p><p>You can also try using gcc to assemble your own assembly files written for MIPSym. GCC won't understand any of the MIPSym syscalls or macros, and it may have trouble with some of the pseudocodes, but you should be able to write something that it can assemble.</p></div> <!-- container --><footer class=footer><span>Last update: 2021 April 15</span></footer></body></html>